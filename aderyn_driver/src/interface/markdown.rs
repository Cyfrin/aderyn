use std::{
    collections::{HashMap, HashSet},
    io::{Result, Write},
    path::{Path, PathBuf},
};

use aderyn_core::{context::workspace::WorkspaceContext, report::*};

use crate::process::WorkspaceContextWrapper;

use super::util::{carve_shortest_path, files_details};

pub fn print_report(
    writer: &mut Box<dyn Write>,
    report: &Report,
    cx_wrapper: &WorkspaceContextWrapper,
    output_rel_path: String,
    no_snippets: bool,
) -> Result<()> {
    let (contexts, root_path) = (&cx_wrapper.contexts, &cx_wrapper.root_path);

    print_title_and_disclaimer(writer.as_mut())?;
    print_table_of_contents(writer.as_mut(), report)?;
    print_contract_summary(writer.as_mut(), report, contexts)?;

    let (high_issues, low_issues) = report.detailed_issues(contexts);

    let all_issues = vec![
        (high_issues.issues, "# High Issues\n", "H"),
        (low_issues.issues, "# Low Issues\n", "L"),
    ];

    let file_contents = contexts
        .iter()
        .flat_map(|context| context.source_units())
        .map(|source_unit| {
            (
                source_unit.absolute_path.as_ref().unwrap().to_owned(),
                source_unit.source.as_ref().unwrap(),
            )
        })
        .collect::<HashMap<_, _>>();

    for (issues, heading, severity) in all_issues {
        let mut counter = 0;

        if !issues.is_empty() {
            writeln!(writer, "{}", heading).unwrap();
            for issue_body in &issues {
                counter += 1;
                print_issue(
                    writer,
                    PrintIssueParams {
                        issue_body,
                        severity,
                        number: counter,
                        root_path,
                        output_rel_path: output_rel_path.clone(),
                        no_snippets,
                    },
                    &file_contents,
                )?;
            }
        }
    }

    Ok(())
}

struct PrintIssueParams<'a> {
    issue_body: &'a IssueBody,
    severity: &'a str,
    number: i32,
    root_path: &'a Path,
    output_rel_path: String,
    no_snippets: bool,
}

fn print_title_and_disclaimer<W: Write>(mut writer: W) -> Result<()> {
    writeln!(writer, "# Aderyn Analysis Report\n")?;
    writeln!(
            writer,
            "This report was generated by [Aderyn](https://github.com/Cyfrin/aderyn), a static analysis tool \
            built by [Cyfrin](https://cyfrin.io), a blockchain security company. This report is not a substitute for manual audit or security review. \
            It should not be relied upon for any purpose other than to assist in the identification of potential security vulnerabilities."
        )?;
    Ok(())
}
fn print_contract_summary<W: Write>(
    mut writer: W,
    report: &Report,
    contexts: &[WorkspaceContext],
) -> Result<()> {
    let mut all_files_details = FilesDetails::default();
    for context in contexts {
        all_files_details = all_files_details + &files_details(context)
    }

    let mut all_files_summary = FilesSummary::default();
    for details in &all_files_details.files_details {
        all_files_summary.total_sloc += details.n_sloc;
        all_files_summary.total_source_units += 1;
    }

    writeln!(writer, "# Summary\n")?;

    // Files Summary
    {
        writeln!(writer, "## Files Summary\n")?;

        // Start the markdown table
        writeln!(writer, "| Key | Value |")?;
        writeln!(writer, "| --- | --- |")?;
        writeln!(writer, "| .sol Files | {} |", all_files_summary.total_source_units)?;
        writeln!(writer, "| Total nSLOC | {} |", all_files_summary.total_sloc)?;

        writeln!(writer, "\n")?; // Add an extra newline for spacing
    }

    // Files Details
    {
        writeln!(writer, "## Files Details\n")?;

        // Start the markdown table with the header
        writeln!(writer, "| Filepath | nSLOC |")?;
        writeln!(writer, "| --- | --- |")?;

        let mut files_details = all_files_details;
        files_details.files_details.sort_by(|a, b| a.file_path.cmp(&b.file_path));

        files_details.files_details.iter().for_each(|detail| {
            writeln!(writer, "| {} | {} |", detail.file_path, detail.n_sloc).unwrap();
        });

        writeln!(writer, "| **Total** | **{}** |", all_files_summary.total_sloc)?;
        writeln!(writer, "\n")?; // Add an extra newline for spacing
    }

    // Analysis Sumarry
    {
        let issue_count = report.issue_count();
        writeln!(writer, "## Issue Summary\n")?;

        // Start the markdown table
        writeln!(writer, "| Category | No. of Issues |")?;
        writeln!(writer, "| --- | --- |")?;
        writeln!(writer, "| High | {} |", issue_count.high)?;
        writeln!(writer, "| Low | {} |", issue_count.low)?;
        writeln!(writer, "\n")?; // Add an extra newline for spacing
    }

    Ok(())
}

fn print_table_of_contents<W: Write>(mut writer: W, report: &Report) -> Result<()> {
    fn print_table_of_content<T>(issues: &[Issue], mut w: T, severity: &str)
    where
        T: Write,
    {
        for (index, issue) in issues.iter().enumerate() {
            let issue_title_slug = issue
                .title
                .to_lowercase()
                .replace(' ', "-")
                .replace(|c: char| !c.is_ascii_alphanumeric() && c != '-', "");
            writeln!(
                w,
                "  - [{}-{}: {}](#{}-{}-{})",
                severity,
                index + 1,
                issue.title,
                severity.to_ascii_lowercase(),
                index + 1,
                issue_title_slug
            )
            .unwrap();
        }
    }

    fn display<T: Write>(title: &str, issues: &[Issue], mut writer: T, severity: &str) {
        if !issues.is_empty() {
            writeln!(writer, "{}", title).unwrap();
            print_table_of_content(issues, &mut writer, severity);
        }
    }

    writeln!(writer, "# Table of Contents\n")?;
    writeln!(writer, "- [Summary](#summary)")?;
    writeln!(writer, "  - [Files Summary](#files-summary)")?;
    writeln!(writer, "  - [Files Details](#files-details)")?;
    writeln!(writer, "  - [Issue Summary](#issue-summary)")?;

    let issues = [
        (&report.highs, "- [High Issues](#high-issues)", "H"),
        (&report.lows, "- [Low Issues](#low-issues)", "L"),
    ];

    issues.iter().for_each(|rec| {
        display(rec.1, rec.0, &mut writer, rec.2);
    });

    writeln!(writer, "\n")?; // Add an extra newline for spacing
    Ok(())
}

fn print_issue(
    writer: &mut Box<dyn Write>,
    params: PrintIssueParams,
    file_data: &HashMap<String, &String>,
) -> Result<()> {
    let is_file = params.root_path.is_file();

    writeln!(
        writer,
        "## {}-{}: {}\n\n{}\n", // <a name> is the anchor for the issue title
        params.severity, params.number, params.issue_body.title, params.issue_body.description
    )?;
    let mut line_nos_printed: HashSet<(String, usize)> = HashSet::new();
    writeln!(
        writer,
        "<details><summary>{} Found Instances</summary>\n\n",
        &params.issue_body.instances.len()
    )?;
    for instance in &params.issue_body.instances {
        // If this line number has already been printed for this issue, skip it
        // This occurs when multiple instances of the same issue are found on the same line.
        // We only want to print the line once in the markdown report.
        // Other formats may want this repetition, but not the markdown report.
        if line_nos_printed.contains(&(instance.contract_path.clone(), instance.line_no)) {
            continue;
        }
        line_nos_printed.insert((instance.contract_path.clone(), instance.line_no));

        let path = {
            if is_file {
                String::from(params.root_path.to_str().unwrap())
            } else {
                // dbg!(&instance.contract_path.clone());
                // String::from("/".to_string() + &instance.contract_path.clone())

                String::from(
                    params
                        .root_path
                        .join(instance.contract_path.clone())
                        .as_path()
                        .to_str()
                        .unwrap(),
                )
            }
        };

        if params.no_snippets {
            writeln!(
                writer,
                "- Found in {} [Line: {}]({}#L{})",
                instance.contract_path,
                instance.line_no,
                carve_shortest_path(
                    std::fs::canonicalize(PathBuf::from(params.output_rel_path.clone())).unwrap(),
                    std::fs::canonicalize(&path).unwrap()
                )
                .to_str()
                .unwrap(),
                instance.line_no,
            )?;
            continue;
        }

        let line = file_data.get(&instance.contract_path).unwrap();

        let line_preview = line.split('\n').skip(instance.line_no - 1).take(1).next().unwrap();

        if let Some(hint) = instance.hint.as_ref() {
            writeln!(
                writer,
                "- Found in {} [Line: {}]({}#L{})\n\n\t{}\n\t```solidity\n\t{}\n\t```\n",
                instance.contract_path,
                instance.line_no,
                carve_shortest_path(
                    std::fs::canonicalize(PathBuf::from(params.output_rel_path.clone())).unwrap(),
                    std::fs::canonicalize(&path).unwrap()
                )
                .to_str()
                .unwrap(),
                instance.line_no,
                hint,
                line_preview,
            )?;
        } else {
            writeln!(
                writer,
                "- Found in {} [Line: {}]({}#L{})\n\n\t```solidity\n\t{}\n\t```\n",
                instance.contract_path,
                instance.line_no,
                carve_shortest_path(
                    std::fs::canonicalize(PathBuf::from(params.output_rel_path.clone())).unwrap(),
                    std::fs::canonicalize(&path).unwrap()
                )
                .to_str()
                .unwrap(),
                instance.line_no,
                line_preview,
            )?;
        }
    }
    writeln!(writer, "</details>\n")?;
    line_nos_printed.clear();
    writeln!(writer, "\n")?; // Add an extra newline for spacing
    Ok(())
}
