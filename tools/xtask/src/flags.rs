xflags::xflags! {
    src "./src/flags.rs"

    cmd xtask {
        cmd cut-release {
            /// Cut a patch release
            optional -p, --patch

            /// Cut a minor release
            optional -m, --minor
        }
        cmd blesspr {}
        cmd reportgen {
            /// Run a specific report by name (from reportgen.toml)
            optional -n, --name name: String

            /// Run all reports
            optional -a, --all

            /// Run reports in parallel (requires --all)
            optional --parallel

            /// Output report names as JSON (for CI matrix)
            optional --list-json

            /// CI verify mode: run setup, generate, diff against baseline
            optional --ci-verify name: String

            /// Run in release mode
            optional --release
        }
        cmd tomlgen{}
    }
}

// generated start
// The following code is generated by `xflags` macro.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
#[derive(Debug)]
pub struct Xtask {
    pub subcommand: XtaskCmd,
}

#[derive(Debug)]
pub enum XtaskCmd {
    CutRelease(CutRelease),
    Blesspr(Blesspr),
    Reportgen(Reportgen),
    Tomlgen(Tomlgen),
}

#[derive(Debug)]
pub struct CutRelease {
    pub patch: bool,
    pub minor: bool,
}

#[derive(Debug)]
pub struct Blesspr;

#[derive(Debug)]
pub struct Reportgen {
    pub name: Option<String>,
    pub all: bool,
    pub parallel: bool,
    pub list_json: bool,
    pub ci_verify: Option<String>,
    pub release: bool,
}

#[derive(Debug)]
pub struct Tomlgen;

impl Xtask {
    #[allow(dead_code)]
    pub fn from_env_or_exit() -> Self {
        Self::from_env_or_exit_()
    }

    #[allow(dead_code)]
    pub fn from_env() -> xflags::Result<Self> {
        Self::from_env_()
    }

    #[allow(dead_code)]
    pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
        Self::from_vec_(args)
    }
}
// generated end
