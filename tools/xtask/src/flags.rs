xflags::xflags! {
    src "./src/flags.rs"

    cmd xtask {
        cmd cut-release {
            /// Cut a patch release
            optional -p, --patch

            /// Cut a minor release
            optional -m, --minor
        }
        cmd blesspr {}
        cmd reportgen {
            /// Run all integration tests
            optional -a, --all

            /// Parallel
            optional --parallel

            /// Sablier
            optional -s, --sablier

            /// Templegold
            optional -t, --tg

            /// AdHoc Sol files
            optional -h, --adhoc

            /// CCIP
            optional -c, --ccip

            /// Contract Playground
            optional -p, --cpg

            /// Foundry NFT
            optional -n, --fnft

            /// Foundry NFT ICM
            optional -i, --fnft-icm

            /// Contract Playrground Uniswap
            optional -u, --cpgu

            /// Hardhat Js Playground
            optional -b, --hhpg

            /// PRB Math
            optional -y, --prb-math

            /// Run in release mode
            optional --release
        }
        cmd tomlgen{}
    }
}

// generated start
// The following code is generated by `xflags` macro.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
#[derive(Debug)]
pub struct Xtask {
    pub subcommand: XtaskCmd,
}

#[derive(Debug)]
pub enum XtaskCmd {
    CutRelease(CutRelease),
    Blesspr(Blesspr),
    Reportgen(Reportgen),
    Tomlgen(Tomlgen),
}

#[derive(Debug)]
pub struct CutRelease {
    pub patch: bool,
    pub minor: bool,
}

#[derive(Debug)]
pub struct Blesspr;

#[derive(Debug)]
pub struct Reportgen {
    pub all: bool,
    pub parallel: bool,
    pub sablier: bool,
    pub tg: bool,
    pub adhoc: bool,
    pub ccip: bool,
    pub cpg: bool,
    pub fnft: bool,
    pub fnft_icm: bool,
    pub cpgu: bool,
    pub hhpg: bool,
    pub prb_math: bool,
    pub release: bool,
}

#[derive(Debug)]
pub struct Tomlgen;

impl Xtask {
    #[allow(dead_code)]
    pub fn from_env_or_exit() -> Self {
        Self::from_env_or_exit_()
    }

    #[allow(dead_code)]
    pub fn from_env() -> xflags::Result<Self> {
        Self::from_env_()
    }

    #[allow(dead_code)]
    pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
        Self::from_vec_(args)
    }
}
// generated end
