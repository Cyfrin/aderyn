use crate::context::loader::ContextLoader;
use std::{
    io::{Result, Write},
    path::{Path, PathBuf},
};

use super::{
    printer::ReportPrinter, reporter::Report, util::carve_shortest_path, Issue, IssueBody,
};

pub struct MarkdownReportPrinter;

impl ReportPrinter<()> for MarkdownReportPrinter {
    fn print_report<W: Write>(
        &self,
        mut writer: W,
        report: &Report,
        loader: &ContextLoader,
        root_path: PathBuf,
        output_rel_path: Option<String>,
    ) -> Result<()> {
        self.print_title_and_disclaimer(&mut writer)?;
        self.print_table_of_contents(&mut writer, report)?;
        self.print_contract_summary(&mut writer, report, loader)?;

        let all_issues = vec![
            (report.critical_issues().issues, "# Critical Issues\n", "C"),
            (report.high_issues().issues, "# High Issues\n", "H"),
            (report.medium_issues().issues, "# Medium Issues\n", "M"),
            (report.low_issues().issues, "# Low Issues\n", "L"),
            (report.nc_issues().issues, "# NC Issues\n", "NC"),
        ];

        for (issues, heading, severity) in all_issues {
            let mut counter = 0;

            if !issues.is_empty() {
                writeln!(writer, "{}", heading).unwrap();
                for issue_body in &issues {
                    counter += 1;
                    self.print_issue(
                        &mut writer,
                        issue_body,
                        severity,
                        counter,
                        &root_path,
                        output_rel_path.clone().unwrap(),
                    )?;
                }
            }
        }

        Ok(())
    }
}

impl MarkdownReportPrinter {
    fn print_title_and_disclaimer<W: Write>(&self, mut writer: W) -> Result<()> {
        writeln!(writer, "# Aderyn Analysis Report\n")?;
        writeln!(
            writer,
            "This report was generated by [Aderyn](https://github.com/Cyfrin/aderyn), a static analysis tool \
            built by [Cyfrin](https://cyfrin.io), a blockchain security company. This report is not a substitute for manual audit or security review. \
            It should not be relied upon for any purpose other than to assist in the identification of potential security vulnerabilities."
        )?;
        Ok(())
    }
    fn print_contract_summary<W: Write>(
        &self,
        mut writer: W,
        report: &Report,
        loader: &ContextLoader,
    ) -> Result<()> {
        writeln!(writer, "# Summary\n")?;

        // Files Summary
        {
            writeln!(writer, "## Files Summary\n")?;
            let files_summary = loader.files_summary();

            // Start the markdown table
            writeln!(writer, "| Key | Value |")?;
            writeln!(writer, "| --- | --- |")?;
            writeln!(
                writer,
                "| .sol Files | {} |",
                files_summary.total_source_units
            )?;
            writeln!(writer, "| Total nSLOC | {} |", files_summary.total_sloc)?;

            writeln!(writer, "\n")?; // Add an extra newline for spacing
        }

        // Files Details
        {
            writeln!(writer, "## Files Details\n")?;

            // Start the markdown table with the header
            writeln!(writer, "| Filepath | nSLOC |")?;
            writeln!(writer, "| --- | --- |")?;

            let files_details = loader.files_details();

            files_details.files_details.iter().for_each(|detail| {
                writeln!(writer, "| {} | {} |", detail.file_path, detail.n_sloc).unwrap();
            });

            let sloc_stats = &loader.sloc_stats;
            writeln!(writer, "| **Total** | **{}** |", sloc_stats.code)?;
            writeln!(writer, "\n")?; // Add an extra newline for spacing
        }

        // Analysis Sumarry
        {
            let issue_count = report.issue_count();
            writeln!(writer, "## Issue Summary\n")?;

            // Start the markdown table
            writeln!(writer, "| Category | No. of Issues |")?;
            writeln!(writer, "| --- | --- |")?;
            writeln!(writer, "| Critical | {} |", issue_count.critical)?;
            writeln!(writer, "| High | {} |", issue_count.high)?;
            writeln!(writer, "| Medium | {} |", issue_count.medium)?;
            writeln!(writer, "| Low | {} |", issue_count.low)?;
            writeln!(writer, "| NC | {} |", issue_count.nc)?;
            writeln!(writer, "\n")?; // Add an extra newline for spacing
        }

        Ok(())
    }

    fn print_table_of_contents<W: Write>(&self, mut writer: W, report: &Report) -> Result<()> {
        fn print_table_of_content<T>(issues: &[Issue], mut w: T, severity: &str)
        where
            T: Write,
        {
            for (index, issue) in issues.iter().enumerate() {
                let issue_title_slug = issue
                    .title
                    .to_lowercase()
                    .replace(' ', "-")
                    .replace(|c: char| !c.is_ascii_alphanumeric() && c != '-', "");
                writeln!(
                    w,
                    "  - [{}-{}: {}](#{}-{}-{})",
                    severity,
                    index + 1,
                    issue.title,
                    severity.to_ascii_lowercase(),
                    index + 1,
                    issue_title_slug
                )
                .unwrap();
            }
        }

        fn display<T: Write>(title: &str, issues: &[Issue], mut writer: T, severity: &str) {
            if !issues.is_empty() {
                writeln!(writer, "{}", title).unwrap();
                print_table_of_content(issues, &mut writer, severity);
            }
        }

        writeln!(writer, "# Table of Contents\n")?;
        writeln!(writer, "- [Summary](#summary)")?;
        writeln!(writer, "  - [Files Summary](#files-summary)")?;
        writeln!(writer, "  - [Files Details](#files-details)")?;
        writeln!(writer, "  - [Issue Summary](#issue-summary)")?;

        let issues = [
            (
                &report.criticals,
                "- [Critical Issues](#critical-issues)",
                "C",
            ),
            (&report.highs, "- [High Issues](#high-issues)", "H"),
            (&report.mediums, "- [Medium Issues](#medium-issues)", "M"),
            (&report.lows, "- [Low Issues](#low-issues)", "L"),
            (&report.ncs, "- [NC Issues](#nc-issues)", "NC"),
        ];

        issues.iter().for_each(|rec| {
            display(rec.1, rec.0, &mut writer, rec.2);
        });

        writeln!(writer, "\n")?; // Add an extra newline for spacing
        Ok(())
    }

    fn print_issue<W: Write>(
        &self,
        mut writer: W,
        issue_body: &IssueBody,
        severity: &str,
        number: i32,
        root_path: &Path,
        output_rel_path: String,
    ) -> Result<()> {
        let is_file = root_path.is_file();

        writeln!(
            writer,
            "## {}-{}: {}\n\n{}\n", // <a name> is the anchor for the issue title
            severity, number, issue_body.title, issue_body.description
        )?;
        for instance in &issue_body.instances {
            let path = {
                if is_file {
                    String::from(root_path.to_str().unwrap())
                } else {
                    String::from(
                        root_path
                            .join(instance.contract_path.clone())
                            .as_path()
                            .to_str()
                            .unwrap(),
                    )
                }
            };

            let line = std::fs::read_to_string(&path).unwrap();

            let line_preview = line
                .split('\n')
                .skip(instance.line_no - 1)
                .take(1)
                .next()
                .unwrap();

            writeln!(
                writer,
                "- Found in {} [Line: {}]({}#L{})\n\n\t```solidity\n\t{}\n\t```\n",
                instance.contract_path,
                instance.line_no,
                carve_shortest_path(
                    std::fs::canonicalize(PathBuf::from(output_rel_path.clone())).unwrap(),
                    std::fs::canonicalize(&path).unwrap()
                )
                .to_str()
                .unwrap(),
                instance.line_no,
                line_preview,
            )?;
        }
        writeln!(writer, "\n")?; // Add an extra newline for spacing
        Ok(())
    }
}
