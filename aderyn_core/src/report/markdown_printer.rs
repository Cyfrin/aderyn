use crate::context::workspace_context::WorkspaceContext;

use std::{
    collections::HashSet,
    io::{Result, Write},
    path::{Path, PathBuf},
};

use super::{
    printer::ReportPrinter, reporter::Report, util::carve_shortest_path, FilesDetails,
    FilesSummary, Issue, IssueBody,
};

pub struct MarkdownReportPrinter;

impl ReportPrinter<()> for MarkdownReportPrinter {
    fn print_report<W: Write>(
        &self,
        mut writer: W,
        report: &Report,
        contexts: &[WorkspaceContext],
        root_path: PathBuf,
        output_rel_path: Option<String>,
        no_snippets: bool,
        _: bool,
        _: &[(String, String)],
    ) -> Result<()> {
        self.print_title_and_disclaimer(&mut writer)?;
        self.print_table_of_contents(&mut writer, report)?;
        self.print_contract_summary(&mut writer, report, contexts)?;

        let output_rel_path = output_rel_path.unwrap();

        let all_issues = vec![
            (report.high_issues().issues, "# High Issues\n", "H"),
            (report.low_issues().issues, "# Low Issues\n", "L"),
        ];

        for (issues, heading, severity) in all_issues {
            let mut counter = 0;

            if !issues.is_empty() {
                writeln!(writer, "{}", heading).unwrap();
                for issue_body in &issues {
                    counter += 1;
                    self.print_issue(
                        &mut writer,
                        PrintIssueParams {
                            issue_body,
                            severity,
                            number: counter,
                            root_path: &root_path,
                            output_rel_path: output_rel_path.clone(),
                            no_snippets,
                        },
                    )?;
                }
            }
        }

        Ok(())
    }
}

struct PrintIssueParams<'a> {
    issue_body: &'a IssueBody,
    severity: &'a str,
    number: i32,
    root_path: &'a Path,
    output_rel_path: String,
    no_snippets: bool,
}

impl MarkdownReportPrinter {
    fn print_title_and_disclaimer<W: Write>(&self, mut writer: W) -> Result<()> {
        writeln!(writer, "# Aderyn Analysis Report\n")?;
        writeln!(
            writer,
            "This report was generated by [Aderyn](https://github.com/Cyfrin/aderyn), a static analysis tool \
            built by [Cyfrin](https://cyfrin.io), a blockchain security company. This report is not a substitute for manual audit or security review. \
            It should not be relied upon for any purpose other than to assist in the identification of potential security vulnerabilities."
        )?;
        Ok(())
    }
    fn print_contract_summary<W: Write>(
        &self,
        mut writer: W,
        report: &Report,
        contexts: &[WorkspaceContext],
    ) -> Result<()> {
        let mut all_files_details = FilesDetails::default();
        for context in contexts {
            all_files_details = all_files_details + &context.files_details();
        }

        let mut all_files_summary = FilesSummary::default();
        for details in &all_files_details.files_details {
            all_files_summary.total_sloc += details.n_sloc;
            all_files_summary.total_source_units += 1;
        }

        writeln!(writer, "# Summary\n")?;

        // Files Summary
        {
            writeln!(writer, "## Files Summary\n")?;

            // Start the markdown table
            writeln!(writer, "| Key | Value |")?;
            writeln!(writer, "| --- | --- |")?;
            writeln!(
                writer,
                "| .sol Files | {} |",
                all_files_summary.total_source_units
            )?;
            writeln!(writer, "| Total nSLOC | {} |", all_files_summary.total_sloc)?;

            writeln!(writer, "\n")?; // Add an extra newline for spacing
        }

        // Files Details
        {
            writeln!(writer, "## Files Details\n")?;

            // Start the markdown table with the header
            writeln!(writer, "| Filepath | nSLOC |")?;
            writeln!(writer, "| --- | --- |")?;

            let mut files_details = all_files_details;
            files_details
                .files_details
                .sort_by(|a, b| a.file_path.cmp(&b.file_path));

            files_details.files_details.iter().for_each(|detail| {
                writeln!(writer, "| {} | {} |", detail.file_path, detail.n_sloc).unwrap();
            });

            writeln!(
                writer,
                "| **Total** | **{}** |",
                all_files_summary.total_sloc
            )?;
            writeln!(writer, "\n")?; // Add an extra newline for spacing
        }

        // Analysis Sumarry
        {
            let issue_count = report.issue_count();
            writeln!(writer, "## Issue Summary\n")?;

            // Start the markdown table
            writeln!(writer, "| Category | No. of Issues |")?;
            writeln!(writer, "| --- | --- |")?;
            writeln!(writer, "| High | {} |", issue_count.high)?;
            writeln!(writer, "| Low | {} |", issue_count.low)?;
            writeln!(writer, "\n")?; // Add an extra newline for spacing
        }

        Ok(())
    }

    fn print_table_of_contents<W: Write>(&self, mut writer: W, report: &Report) -> Result<()> {
        fn print_table_of_content<T>(issues: &[Issue], mut w: T, severity: &str)
        where
            T: Write,
        {
            for (index, issue) in issues.iter().enumerate() {
                let issue_title_slug = issue
                    .title
                    .to_lowercase()
                    .replace(' ', "-")
                    .replace(|c: char| !c.is_ascii_alphanumeric() && c != '-', "");
                writeln!(
                    w,
                    "  - [{}-{}: {}](#{}-{}-{})",
                    severity,
                    index + 1,
                    issue.title,
                    severity.to_ascii_lowercase(),
                    index + 1,
                    issue_title_slug
                )
                .unwrap();
            }
        }

        fn display<T: Write>(title: &str, issues: &[Issue], mut writer: T, severity: &str) {
            if !issues.is_empty() {
                writeln!(writer, "{}", title).unwrap();
                print_table_of_content(issues, &mut writer, severity);
            }
        }

        writeln!(writer, "# Table of Contents\n")?;
        writeln!(writer, "- [Summary](#summary)")?;
        writeln!(writer, "  - [Files Summary](#files-summary)")?;
        writeln!(writer, "  - [Files Details](#files-details)")?;
        writeln!(writer, "  - [Issue Summary](#issue-summary)")?;

        let issues = [
            (&report.highs, "- [High Issues](#high-issues)", "H"),
            (&report.lows, "- [Low Issues](#low-issues)", "L"),
        ];

        issues.iter().for_each(|rec| {
            display(rec.1, rec.0, &mut writer, rec.2);
        });

        writeln!(writer, "\n")?; // Add an extra newline for spacing
        Ok(())
    }

    fn print_issue<W: Write>(&self, mut writer: W, params: PrintIssueParams) -> Result<()> {
        let is_file = params.root_path.is_file();

        writeln!(
            writer,
            "## {}-{}: {}\n\n{}\n", // <a name> is the anchor for the issue title
            params.severity, params.number, params.issue_body.title, params.issue_body.description
        )?;
        let mut line_nos_printed: HashSet<(String, usize)> = HashSet::new();
        writeln!(
            writer,
            "<details><summary>{} Found Instances</summary>\n\n",
            &params.issue_body.instances.len()
        )?;
        for instance in &params.issue_body.instances {
            // If this line number has already been printed for this issue, skip it
            // This occurs when multiple instances of the same issue are found on the same line.
            // We only want to print the line once in the markdown report.
            // Other formats may want this repition, but not the markdown report.
            if line_nos_printed.contains(&(instance.contract_path.clone(), instance.line_no)) {
                continue;
            }
            line_nos_printed.insert((instance.contract_path.clone(), instance.line_no));

            let path = {
                if is_file {
                    String::from(params.root_path.to_str().unwrap())
                } else {
                    // dbg!(&instance.contract_path.clone());
                    // String::from("/".to_string() + &instance.contract_path.clone())

                    String::from(
                        params
                            .root_path
                            .join(instance.contract_path.clone())
                            .as_path()
                            .to_str()
                            .unwrap(),
                    )
                }
            };

            if params.no_snippets {
                writeln!(
                    writer,
                    "- Found in {} [Line: {}]({}#L{})",
                    instance.contract_path,
                    instance.line_no,
                    carve_shortest_path(
                        std::fs::canonicalize(PathBuf::from(params.output_rel_path.clone()))
                            .unwrap(),
                        std::fs::canonicalize(&path).unwrap()
                    )
                    .to_str()
                    .unwrap(),
                    instance.line_no,
                )?;
                continue;
            }

            // dbg!(&params.root_path);
            // dbg!(&instance.contract_path.clone());
            // dbg!(&path);
            let line = std::fs::read_to_string(&path).unwrap();

            let line_preview = line
                .split('\n')
                .skip(instance.line_no - 1)
                .take(1)
                .next()
                .unwrap();

            writeln!(
                writer,
                "- Found in {} [Line: {}]({}#L{})\n\n\t```solidity\n\t{}\n\t```\n",
                instance.contract_path,
                instance.line_no,
                carve_shortest_path(
                    std::fs::canonicalize(PathBuf::from(params.output_rel_path.clone())).unwrap(),
                    std::fs::canonicalize(&path).unwrap()
                )
                .to_str()
                .unwrap(),
                instance.line_no,
                line_preview,
            )?;
        }
        writeln!(writer, "</details>\n")?;
        line_nos_printed.clear();
        writeln!(writer, "\n")?; // Add an extra newline for spacing
        Ok(())
    }
}
