use crate::context::workspace_context::WorkspaceContext;

use std::{
    io::{Result, Write},
    path::{Path, PathBuf},
};

use super::{
    printer::ReportPrinter, reporter::Report, util::carve_shortest_path, Issue, IssueBody,
};

pub struct MarkdownReportPrinter;

impl ReportPrinter<()> for MarkdownReportPrinter {
    fn print_report<W: Write>(
        &self,
        mut writer: W,
        report: &Report,
        context: &WorkspaceContext,
        root_path: PathBuf,
        output_rel_path: Option<String>,
        no_snippets: bool,
        detectors_used: &[(String, String)],
    ) -> Result<()> {
        self.print_title_and_disclaimer(&mut writer)?;
        self.print_table_of_contents(&mut writer, report)?;
        self.print_contract_summary(&mut writer, report, context)?;

        let output_rel_path = output_rel_path.unwrap();
        let is_for_judge = output_rel_path.clone().ends_with(".judge.md");
        if is_for_judge {
            writeln!(writer, "## Detectors Used\n")?;
            for detector in detectors_used {
                writeln!(writer, "{}:{}\n", detector.0, detector.1)?;
            }
        }

        let all_issues = vec![
            (
                report.critical_issues(context).issues,
                "# Critical Issues\n",
                "C",
            ),
            (report.high_issues(context).issues, "# High Issues\n", "H"),
            (
                report.medium_issues(context).issues,
                "# Medium Issues\n",
                "M",
            ),
            (report.low_issues(context).issues, "# Low Issues\n", "L"),
            (report.nc_issues(context).issues, "# NC Issues\n", "NC"),
        ];

        for (issues, heading, severity) in all_issues {
            let mut counter = 0;

            if !issues.is_empty() {
                writeln!(writer, "{}", heading).unwrap();
                for issue_body in &issues {
                    counter += 1;
                    self.print_issue(
                        &mut writer,
                        PrintIssueParams {
                            issue_body,
                            severity,
                            number: counter,
                            root_path: &root_path,
                            output_rel_path: output_rel_path.clone(),
                            no_snippets,
                        },
                    )?;
                }
            }
        }

        Ok(())
    }
}

struct PrintIssueParams<'a> {
    issue_body: &'a IssueBody,
    severity: &'a str,
    number: i32,
    root_path: &'a Path,
    output_rel_path: String,
    no_snippets: bool,
}

impl MarkdownReportPrinter {
    fn print_title_and_disclaimer<W: Write>(&self, mut writer: W) -> Result<()> {
        writeln!(writer, "# Aderyn Analysis Report\n")?;
        writeln!(
            writer,
            "This report was generated by [Aderyn](https://github.com/Cyfrin/aderyn), a static analysis tool \
            built by [Cyfrin](https://cyfrin.io), a blockchain security company. This report is not a substitute for manual audit or security review. \
            It should not be relied upon for any purpose other than to assist in the identification of potential security vulnerabilities."
        )?;
        Ok(())
    }
    fn print_contract_summary<W: Write>(
        &self,
        mut writer: W,
        report: &Report,
        context: &WorkspaceContext,
    ) -> Result<()> {
        writeln!(writer, "# Summary\n")?;

        // Files Summary
        {
            writeln!(writer, "## Files Summary\n")?;
            let files_summary = context.files_summary();

            // Start the markdown table
            writeln!(writer, "| Key | Value |")?;
            writeln!(writer, "| --- | --- |")?;
            writeln!(
                writer,
                "| .sol Files | {} |",
                files_summary.total_source_units
            )?;
            writeln!(writer, "| Total nSLOC | {} |", files_summary.total_sloc)?;

            writeln!(writer, "\n")?; // Add an extra newline for spacing
        }

        // Files Details
        {
            writeln!(writer, "## Files Details\n")?;

            // Start the markdown table with the header
            writeln!(writer, "| Filepath | nSLOC |")?;
            writeln!(writer, "| --- | --- |")?;

            let files_details = context.files_details();

            files_details.files_details.iter().for_each(|detail| {
                writeln!(writer, "| {} | {} |", detail.file_path, detail.n_sloc).unwrap();
            });

            writeln!(
                writer,
                "| **Total** | **{}** |",
                context.files_summary().total_sloc
            )?;
            writeln!(writer, "\n")?; // Add an extra newline for spacing
        }

        // Analysis Sumarry
        {
            let issue_count = report.issue_count();
            writeln!(writer, "## Issue Summary\n")?;

            // Start the markdown table
            writeln!(writer, "| Category | No. of Issues |")?;
            writeln!(writer, "| --- | --- |")?;
            writeln!(writer, "| Critical | {} |", issue_count.critical)?;
            writeln!(writer, "| High | {} |", issue_count.high)?;
            writeln!(writer, "| Medium | {} |", issue_count.medium)?;
            writeln!(writer, "| Low | {} |", issue_count.low)?;
            writeln!(writer, "| NC | {} |", issue_count.nc)?;
            writeln!(writer, "\n")?; // Add an extra newline for spacing
        }

        Ok(())
    }

    fn print_table_of_contents<W: Write>(&self, mut writer: W, report: &Report) -> Result<()> {
        fn print_table_of_content<T>(issues: &[Issue], mut w: T, severity: &str)
        where
            T: Write,
        {
            for (index, issue) in issues.iter().enumerate() {
                let issue_title_slug = issue
                    .title
                    .to_lowercase()
                    .replace(' ', "-")
                    .replace(|c: char| !c.is_ascii_alphanumeric() && c != '-', "");
                writeln!(
                    w,
                    "  - [{}-{}: {}](#{}-{}-{})",
                    severity,
                    index + 1,
                    issue.title,
                    severity.to_ascii_lowercase(),
                    index + 1,
                    issue_title_slug
                )
                .unwrap();
            }
        }

        fn display<T: Write>(title: &str, issues: &[Issue], mut writer: T, severity: &str) {
            if !issues.is_empty() {
                writeln!(writer, "{}", title).unwrap();
                print_table_of_content(issues, &mut writer, severity);
            }
        }

        writeln!(writer, "# Table of Contents\n")?;
        writeln!(writer, "- [Summary](#summary)")?;
        writeln!(writer, "  - [Files Summary](#files-summary)")?;
        writeln!(writer, "  - [Files Details](#files-details)")?;
        writeln!(writer, "  - [Issue Summary](#issue-summary)")?;

        let issues = [
            (
                &report.criticals,
                "- [Critical Issues](#critical-issues)",
                "C",
            ),
            (&report.highs, "- [High Issues](#high-issues)", "H"),
            (&report.mediums, "- [Medium Issues](#medium-issues)", "M"),
            (&report.lows, "- [Low Issues](#low-issues)", "L"),
            (&report.ncs, "- [NC Issues](#nc-issues)", "NC"),
        ];

        issues.iter().for_each(|rec| {
            display(rec.1, rec.0, &mut writer, rec.2);
        });

        writeln!(writer, "\n")?; // Add an extra newline for spacing
        Ok(())
    }

    fn print_issue<W: Write>(&self, mut writer: W, params: PrintIssueParams) -> Result<()> {
        let is_file = params.root_path.is_file();

        writeln!(
            writer,
            "## {}-{}: {}\n\n{}\n", // <a name> is the anchor for the issue title
            params.severity, params.number, params.issue_body.title, params.issue_body.description
        )?;
        if params.output_rel_path.ends_with(".judge.md") {
            writeln!(
                writer,
                "### Responsible : {}\n",
                params.issue_body.detector_name.clone()
            )?;
        }
        for instance in &params.issue_body.instances {
            let path = {
                if is_file {
                    String::from(params.root_path.to_str().unwrap())
                } else {
                    String::from(
                        params
                            .root_path
                            .join(instance.contract_path.clone())
                            .as_path()
                            .to_str()
                            .unwrap(),
                    )
                }
            };

            if params.no_snippets {
                writeln!(
                    writer,
                    "- Found in {} [Line: {}]({}#L{})",
                    instance.contract_path,
                    instance.line_no,
                    carve_shortest_path(
                        std::fs::canonicalize(PathBuf::from(params.output_rel_path.clone()))
                            .unwrap(),
                        std::fs::canonicalize(&path).unwrap()
                    )
                    .to_str()
                    .unwrap(),
                    instance.line_no,
                )?;
                continue;
            }

            let line = std::fs::read_to_string(&path).unwrap();

            let line_preview = line
                .split('\n')
                .skip(instance.line_no - 1)
                .take(1)
                .next()
                .unwrap();

            writeln!(
                writer,
                "- Found in {} [Line: {}]({}#L{})\n\n\t```solidity\n\t{}\n\t```\n",
                instance.contract_path,
                instance.line_no,
                carve_shortest_path(
                    std::fs::canonicalize(PathBuf::from(params.output_rel_path.clone())).unwrap(),
                    std::fs::canonicalize(&path).unwrap()
                )
                .to_str()
                .unwrap(),
                instance.line_no,
                line_preview,
            )?;
        }
        writeln!(writer, "\n")?; // Add an extra newline for spacing
        Ok(())
    }
}
