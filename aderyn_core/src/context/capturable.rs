use crate::ast::{ContractDefinition, *};

use super::{
    macros::generate_capturable_methods,
    workspace_context::{ASTNode, WorkspaceContext},
};

generate_capturable_methods! {
    ASTNode,
    Assignment,
    BinaryOperation,
    Block,
    Conditional,
    ContractDefinition,
    ElementaryTypeNameExpression,
    EnumDefinition,
    EnumValue,
    EventDefinition,
    ErrorDefinition,
    FunctionCall,
    FunctionCallOptions,
    FunctionDefinition,
    ForStatement,
    Identifier,
    IdentifierPath,
    IfStatement,
    ImportDirective,
    IndexAccess,
    IndexRangeAccess,
    InheritanceSpecifier,
    InlineAssembly,
    Literal,
    MemberAccess,
    NewExpression,
    ModifierDefinition,
    ModifierInvocation,
    OverrideSpecifier,
    ParameterList,
    PragmaDirective,
    Return,
    SourceUnit,
    StructDefinition,
    StructuredDocumentation,
    TupleExpression,
    UnaryOperation,
    UserDefinedValueTypeDefinition,
    UsingForDirective,
    VariableDeclaration,
    VariableDeclarationStatement,
    WhileStatement,
    DoWhileStatement,
    Break,
    Continue,
    PlaceholderStatement,
}

impl Capturable {
    pub fn make_key(&self, context: &WorkspaceContext) -> (String, usize, String) {
        match self {
            Self::ASTNode(node) => context.get_node_sort_key(node),
            Self::Assignment(n) => context.get_node_sort_key(&n.into()),
            Self::BinaryOperation(n) => context.get_node_sort_key(&n.into()),
            Self::Block(n) => context.get_node_sort_key(&n.into()),
            Self::Conditional(n) => context.get_node_sort_key(&n.into()),
            Self::ContractDefinition(n) => context.get_node_sort_key(&n.into()),
            Self::ElementaryTypeNameExpression(n) => context.get_node_sort_key(&n.into()),
            Self::EnumDefinition(n) => context.get_node_sort_key(&n.into()),
            Self::EnumValue(n) => context.get_node_sort_key(&n.into()),
            Self::EventDefinition(n) => context.get_node_sort_key(&n.into()),
            Self::ErrorDefinition(n) => context.get_node_sort_key(&n.into()),
            Self::FunctionCall(n) => context.get_node_sort_key(&n.into()),
            Self::FunctionCallOptions(n) => context.get_node_sort_key(&n.into()),
            Self::FunctionDefinition(n) => context.get_node_sort_key(&n.into()),
            Self::ForStatement(n) => context.get_node_sort_key(&n.into()),
            Self::Identifier(n) => context.get_node_sort_key(&n.into()),
            Self::IdentifierPath(n) => context.get_node_sort_key(&n.into()),
            Self::IfStatement(n) => context.get_node_sort_key(&n.into()),
            Self::ImportDirective(n) => context.get_node_sort_key(&n.into()),
            Self::IndexAccess(n) => context.get_node_sort_key(&n.into()),
            Self::IndexRangeAccess(n) => context.get_node_sort_key(&n.into()),
            Self::InheritanceSpecifier(n) => context.get_node_sort_key(&n.into()),
            Self::InlineAssembly(n) => context.get_node_sort_key(&n.into()),
            Self::Literal(n) => context.get_node_sort_key(&n.into()),
            Self::MemberAccess(n) => context.get_node_sort_key(&n.into()),
            Self::NewExpression(n) => context.get_node_sort_key(&n.into()),
            Self::ModifierDefinition(n) => context.get_node_sort_key(&n.into()),
            Self::ModifierInvocation(n) => context.get_node_sort_key(&n.into()),
            Self::OverrideSpecifier(n) => context.get_node_sort_key(&n.into()),
            Self::ParameterList(n) => context.get_node_sort_key(&n.into()),
            Self::PragmaDirective(n) => context.get_node_sort_key(&n.into()),
            Self::Return(n) => context.get_node_sort_key(&n.into()),
            Self::SourceUnit(n) => context.get_node_sort_key(&n.into()),
            Self::StructDefinition(n) => context.get_node_sort_key(&n.into()),
            Self::StructuredDocumentation(n) => context.get_node_sort_key(&n.into()),
            Self::TupleExpression(n) => context.get_node_sort_key(&n.into()),
            Self::UnaryOperation(n) => context.get_node_sort_key(&n.into()),
            Self::UserDefinedValueTypeDefinition(n) => context.get_node_sort_key(&n.into()),
            Self::UsingForDirective(n) => context.get_node_sort_key(&n.into()),
            Self::VariableDeclaration(n) => context.get_node_sort_key(&n.into()),
            Self::VariableDeclarationStatement(n) => context.get_node_sort_key(&n.into()),
            Self::WhileStatement(n) => context.get_node_sort_key(&n.into()),
            Self::DoWhileStatement(n) => context.get_node_sort_key(&n.into()),
            Self::Break(n) => context.get_node_sort_key(&n.into()),
            Self::Continue(n) => context.get_node_sort_key(&n.into()),
            Self::PlaceholderStatement(n) => context.get_node_sort_key(&n.into()),
        }
    }

    pub fn id(&self) -> Option<NodeID> {
        match self {
            Self::ASTNode(ast_node) => ast_node.id(),
            Self::Assignment(n) => Some(n.id),
            Self::BinaryOperation(n) => Some(n.id),
            Self::Block(n) => Some(n.id),
            Self::Conditional(n) => Some(n.id),
            Self::ContractDefinition(n) => Some(n.id),
            Self::ElementaryTypeNameExpression(n) => Some(n.id),
            Self::EnumDefinition(n) => Some(n.id),
            Self::EnumValue(n) => Some(n.id),
            Self::EventDefinition(n) => Some(n.id),
            Self::ErrorDefinition(n) => Some(n.id),
            Self::FunctionCall(n) => Some(n.id),
            Self::FunctionCallOptions(n) => Some(n.id),
            Self::FunctionDefinition(n) => Some(n.id),
            Self::ForStatement(n) => Some(n.id),
            Self::Identifier(n) => Some(n.id),
            Self::IdentifierPath(n) => Some(n.id),
            Self::IfStatement(n) => Some(n.id),
            Self::ImportDirective(n) => Some(n.id),
            Self::IndexAccess(n) => Some(n.id),
            Self::IndexRangeAccess(n) => Some(n.id),
            Self::InheritanceSpecifier(n) => Some(n.id),
            Self::InlineAssembly(n) => Some(n.id),
            Self::Literal(n) => Some(n.id),
            Self::MemberAccess(n) => Some(n.id),
            Self::NewExpression(n) => Some(n.id),
            Self::ModifierDefinition(n) => Some(n.id),
            Self::ModifierInvocation(n) => Some(n.id),
            Self::OverrideSpecifier(n) => Some(n.id),
            Self::ParameterList(n) => Some(n.id),
            Self::PragmaDirective(n) => Some(n.id),
            Self::Return(n) => Some(n.id),
            Self::SourceUnit(n) => Some(n.id),
            Self::StructDefinition(n) => Some(n.id),
            Self::StructuredDocumentation(n) => Some(n.id),
            Self::TupleExpression(n) => Some(n.id),
            Self::UnaryOperation(n) => Some(n.id),
            Self::UserDefinedValueTypeDefinition(n) => Some(n.id),
            Self::UsingForDirective(n) => Some(n.id),
            Self::VariableDeclaration(n) => Some(n.id),
            Self::VariableDeclarationStatement(n) => Some(n.id),
            Self::WhileStatement(n) => Some(n.id),
            Self::DoWhileStatement(n) => Some(n.id),
            Self::Break(n) => Some(n.id),
            Self::Continue(n) => Some(n.id),
            Self::PlaceholderStatement(n) => Some(n.id),
        }
    }
}

impl From<&&ContractDefinition> for Capturable {
    fn from(value: &&ContractDefinition) -> Self {
        #[allow(suspicious_double_ref_op)]
        Self::ContractDefinition(value.clone().clone())
    }
}

impl From<&&ModifierInvocation> for Capturable {
    fn from(value: &&ModifierInvocation) -> Self {
        #[allow(suspicious_double_ref_op)]
        Self::ModifierInvocation(value.clone().clone())
    }
}
